import random
from decimal import *

# Tried my hand on manually implementing builtin round() :P

def manual_round(number, ndigits=None):
    '''
    This function emulates python's inbuilt round(number[,ndigits]) function.

    Returns number rounded to ndigits precision after the decimal point. 
    It implements Banker's rounding algorithm. 

    - If ndigits is omitted or is None, it returns the nearest integer to its input.
    - Values are rounded to the closest multiple of -> 10 to the power negative ndigits
    - If two multiples are equally close, rounding is done toward the even choice

    Any integer value is valid for ndigits (positive, zero, or negative)   
    '''
    # try:
    #     number = float(number)
    # except Exception as exception:
    #     raise TypeError(exception)

    if not (type(number) is int or type(number) is float):
        raise TypeError(f"must be real number, not {type(number).__name__}")

    if ndigits is None:
        ndigits = 0

    if type(ndigits) is not int:
        raise TypeError(f"must be int, not {type(number).__name__}")

    if number == 0.0:
        return number

    sign  = (-1, 1)[number>0]
    number = abs(number)

    if ndigits <= 0:

        pow_10_multiple = 10**(-ndigits)
        int_quotient = number//pow_10_multiple
        floorn = pow_10_multiple*int_quotient
        ceiln = pow_10_multiple*(int_quotient+1)

        if (number - floorn) == (ceiln - number):
            rval = sign*(floorn if floorn % (2*pow_10_multiple) == 0 else ceiln)
        elif (number - floorn) > (ceiln - number):
            rval = sign*ceiln
        else: 
            rval = sign*floorn

        if ndigits == 0:
            return int(rval)

        return rval

    if ndigits > 0:
        f_str = "{:.100f}".format(number)
        intp, decp = f_str.split(".")

        if len(decp) <= ndigits:
            return sign*float(f_str)

        p5 = float("0." + decp[ndigits:])

        round_str = decp[:ndigits]

        if p5 == 0.5:
            if int(decp[ndigits-1])%2 == 0:
                rstr = intp + "." + round_str
            else:
                rstr = intp + "." + str(int(round_str)+1).zfill(len(round_str))
        elif p5 < 0.5:
            rstr = intp + "." + round_str
        elif p5 > 0.5:
            rstr = intp + "." + str(int(round_str)+1).zfill(len(round_str))
        return sign*float(rstr)

class Qualean:
    '''
    A class similar to Boolean. But it has a *quantum nature* added to it, thereby its name "Qualean".

    It takes in one of the three values [-1, 0, 1] -> Maybe, False and True respectively.
    Instead of storing them as they are:
    --it internally picks a pseudo random between [-1, 1)
    --multiplies it with the input value and stores the result

    '''
    def __init__(self, number: int = 1):
        '''
        Initializes the Qualean object. It takes one argument "number".

        Default value of "number" is 1. 

        It defines two data members:

        1. "number" -> public -> user input
        2. "__qualean" -> private -> computed value

        "number" is the user input and can be one of [-1, 0, 1].

        "__qualean" is generated by:
            1. first choosing a random between [-1,1) using random.uniform(-1,1)
            2. rounding the above value to 10 decimal places: manual_round(value,10)
            3. then storing the result to __qualean
        '''
        # if number is None:
        #     number = random.choice([-1, 0, 1])
        if number not in [-1, 0, 1]:
            raise ValueError(f"Invalid input: input value must be one of [-1, 0, 1]")
        self.number =  number
        self.__qualeen = manual_round(self.number*random.uniform(-1,1), 10)

    def return_qualean(self):
        '''
        Returns qualean value
        '''
        return self.__qualeen

    def __bool__(self):
        '''
        Returns boolean of qualean value
        '''
        return bool(self.__qualeen)

    def __str__(self):
        '''
        String representation of Qualean object
        '''
        return f'Qualean String for number: ' + str(self.number)

    def __repr__(self):
        '''
        String describing the Qualean object
        '''
        return f'Qualean Class Instance'

    def __float__(self):
        '''
        Returns float of qualean value 
        '''
        return self.__qualeen

    def __invertsign__(self):
        '''
        Inverts the sign of qualean value and returns the result  
        '''
        return -self.__qualeen
 

    #########################################
    ########### LOGICAL OPERATORS ###########
    #########################################

    def __and__(self, q2=None):
        '''
        Function implements Logical "and" operator for Qualean objects

        Returns True only if both the operands are True
        '''
        if q2 is None:
            return False
        if not isinstance(q2, Qualean):
            return bool(self.__qualeen and q2)
        return bool(self.__qualeen and q2.return_qualean())

    def __or__(self, q2=None):
        '''
        Function implements Logical "or" operator for Qualean objects

        Returns True if any of the operands is True
        '''
        if q2 is None:
            return bool(self.__qualeen)
        if not isinstance(q2, Qualean):
            return bool(self.__qualeen or q2)
        return bool(self.__qualeen or q2.return_qualean())

    ############################################
    ########### ARITHMETIC OPERATORS ###########
    ############################################

    def __add__(self, q2):
        '''
        Function implements Arithmetic "addition" operator for Qualean objects
        The second operand can either be a Qualean object or a real number 

        Returns the sum of qualean values of the operands (of type Qualean)
        (OR)
        If the second operand is real number, 
        Returns the sum of qualean value of the first operand and the real value
        '''
        if q2 is None or not (isinstance(q2, int) or isinstance(q2, float) or isinstance(q2, Qualean)):
            raise TypeError(f"unsupported operand type(s) for __add__: 'Qualean' and '{type(q2).__name__}'")
        if not isinstance(q2, Qualean):
            return self.__qualeen + q2
        return self.__qualeen + q2.return_qualean()

    def __mul__(self, q2):
        '''
        Function implements Arithmetic "multiplication" operator for Qualean objects
        The second operand can either be a Qualean object or a real number 

        Returns the product of qualean values of the operands (of type Qualean)
        (OR)
        If the second operand is real number, 
        Returns the sum of qualean value of the first operand and the real value
        '''
        if q2 is None or not (isinstance(q2, int) or isinstance(q2, float) or isinstance(q2, Qualean)):
            raise TypeError(f"unsupported operand type(s) for __mul__: 'Qualean' and '{type(q2).__name__}'")
        if not isinstance(q2, Qualean):
            return self.__qualeen * q2
        return self.__qualeen * q2.return_qualean()

    def __sqrt__(self):
        '''
        Finds the square root of qualean value
        '''
        if self.__qualeen>=0:
            return abs(Decimal(self.__qualeen)).sqrt()
        else:

            # if the qualean value is negative return square root of the magnitude, multiplied with the imaginary unit "i" 
            return str(manual_round(float(Decimal(self.__invertsign__()).sqrt()), 10)) + 'i'

            # to return the value in float
            # return round(Decimal(self.__invertsign__()).sqrt(), 10)*1j

    ############################################
    ########### COMPARISON OPERATORS ###########
    ############################################

    def __eq__(self, q2):
        '''
        Function implements comparison "is equal to" operator on Qualean objects
        The second operand can either be a Qualean object or a real number 

        Returns True if both qualean values of the operands (of type Qualean) are equal
        (OR)
        If the second operand is real number, 
        Returns True if the qualean value of the first operand (of type Qualean) and the real value are equal
        '''
        if q2 is None or not (isinstance(q2, int) or isinstance(q2, float) or isinstance(q2, Qualean)):
            raise TypeError(f"unsupported operand type(s) for __eq__: 'Qualean' and '{type(q2).__name__}'")
        if not isinstance(q2, Qualean):
            return self.__qualeen == q2
        return self.__qualeen == q2.return_qualean()

    def __ge__(self, q2):
        '''
        Function implements comparison "is greater than or equal to" operator on Qualean objects
        The second operand can either be a Qualean object or a real number 

        Returns True if the first operand is greater than or equal to the second operand (both of type Qualean)
        (OR)
        If the second operand is real number, 
        Returns True if the qualean value of the first operand  (of type Qualean) is greater than or equal to the real value
        '''
        if q2 is None or not (isinstance(q2, int) or isinstance(q2, float) or isinstance(q2, Qualean)):
            raise TypeError(f"unsupported operand type(s) for __ge__: 'Qualean' and '{type(q2).__name__}'")
        if not isinstance(q2, Qualean):
            return self.__qualeen >= q2
        return self.__qualeen >= q2.return_qualean()

    def __gt__(self, q2):
        '''
        Function implements comparison "is greater than" operator on Qualean objects
        The second operand can either be a Qualean object or a real number 

        Returns True if the first operand is greater than the second operand (both of type Qualean)
        (OR)
        If the second operand is real number, 
        Returns True if the qualean value of the first operand (of type Qualean) is greater than the real value
        '''
        if q2 is None or not (isinstance(q2, int) or isinstance(q2, float) or isinstance(q2, Qualean)):
            raise TypeError(f"unsupported operand type(s) for __gt__: 'Qualean' and '{type(q2).__name__}'")
        if not isinstance(q2, Qualean):
            return self.__qualeen > q2
        return self.__qualeen > q2.return_qualean()

    def __le__(self, q2):
        '''
        Function implements comparison "is less than or equal to" operator on Qualean objects
        The second operand can either be a Qualean object or a real number 

        Returns True if the first operand is less than or equal to the second operand (both of type Qualean)
        (OR)
        If the second operand is real number, 
        Returns True if the qualean value of the first operand  (of type Qualean) is less than or equal to the real value
        '''
        if q2 is None or not (isinstance(q2, int) or isinstance(q2, float) or isinstance(q2, Qualean)):
            raise TypeError(f"unsupported operand type(s) for __le__: 'Qualean' and '{type(q2).__name__}'")
        if not isinstance(q2, Qualean):
            return self.__qualeen <= q2
        return self.__qualeen <= q2.return_qualean()

    def __lt__(self, q2):
        '''
        Function implements comparison "is less than" operator on Qualean objects
        The second operand can either be a Qualean object or a real number 

        Returns True if the first operand is less than the second operand (both of type Qualean)
        (OR)
        If the second operand is real number, 
        Returns True if the qualean value of the first operand (of type Qualean) is less than the real value
        '''
        if q2 is None or not (isinstance(q2, int) or isinstance(q2, float) or isinstance(q2, Qualean)):
            raise TypeError(f"unsupported operand type(s) for __lt__: 'Qualean' and '{type(q2).__name__}'")
        if not isinstance(q2, Qualean):
            return self.__qualeen < q2
        return self.__qualeen < q2.return_qualean()